#!/usr/bin/env python
# -*- coding: utf-8 -*-

from __future__ import (absolute_import, division,
                        print_function, unicode_literals)

import argparse
import datetime
import os,sys
import ntpath
import json
import glob
import urllib.request

"""
   _____ _______    _______            __  __ _    _ _______    _______ _____ ____  _   _ 
  / ____|__   __|/\|__   __|          |  \/  | |  | |__   __|/\|__   __|_   _/ __ \| \ | |
 | |       | |  /  \  | |     ______  | \  / | |  | |  | |  /  \  | |    | || |  | |  \| |
 | |       | | / /\ \ | |    |______| | |\/| | |  | |  | | / /\ \ | |    | || |  | | . ` |
 | |____   | |/ ____ \| |             | |  | | |__| |  | |/ ____ \| |   _| || |__| | |\  |
  \_____|  |_/_/    \_\_|             |_|  |_|\____/   |_/_/    \_\_|  |_____\____/|_| \_|
"""

VERSION = "__BLEEDING_EDGE__"

sys.path.insert(0, os.path.sep.join([os.path.dirname(os.path.realpath(__file__)), "PyLib"]))
from Pipeliner import Pipeliner, Command, run_cmd
import logging
FORMAT = "%(asctime)-15s: %(levelname)s %(module)s.%(name)s.%(funcName)s %(message)s"
logger = logging.getLogger('ctat_mutations')
logging.basicConfig(stream=sys.stderr, format=FORMAT, level=logging.INFO)

## Path to supporting scripts
SCRIPTDIR = os.path.sep.join([os.path.dirname(os.path.realpath(__file__)), "src"])

# Directory structure
STR_MISC_DIR = "misc"

# STAR alignment options
STR_ALIGN_STAR = "STAR"

# STAR key words and staticly named files
STR_STAR_GENOME_GENERATE = "genomeGenerate"
STR_STAR_JUNCTION = "SJ.out.tab"
STR_STAR_LOG = "Log.out"
STR_STAR_LOG_FINAL = "Log.final.out"
STR_STAR_OUTPUT_BAM = "Aligned.sortedByCoord.out.bam"
STR_STAR_PROGRESS = "Log.progress.out"

# Variant Calling modes - GATK or NONE
STR_VARIANT_GATK = "GATK"
STR_VARIANT_NONE = "NONE"
LSTR_VARIANT_CALLING_CHOICES = [STR_VARIANT_GATK,
                                STR_VARIANT_NONE]

# PICARD platforms
# Choices for platform
STR_ILLUMINA = "ILLUMINA"
LSTR_SEQ_CHOICES = [STR_ILLUMINA, "SLX,SOLEXA",
                    "SOLID,454", "COMPLETE",
                    "PACBIO", "IONTORRENT",
                    "CAPILLARY", "ONT"]

# GATK variant callers
STR_GATK_HC = "HaplotypeCaller"
STR_GATK_MUTECT2 = "Mutect2"
LSTR_VARIANT_METHOD_CHOICES = [STR_GATK_HC,
                                STR_GATK_MUTECT2]

# Choices for variant filtering
STR_FILTERING_BCFTOOLS = "BCFTOOLS"
STR_FILTERING_HC_REGULAR = "HC_REGULAR"
STR_FILTERING_HC_CNN = "HC_CNN"
STR_FILTERING_MUTECT2_REGULAR = "MUTECT2_REGULAR"
STR_FILTERING_MUTECT2_LROM = "MUTECT2_LROM"
STR_FILTERING_NONE = "NONE"

LSTR_VARIANT_FILTERING_CHOICES = [STR_FILTERING_HC_REGULAR,
                                  STR_FILTERING_HC_CNN,
                                  STR_FILTERING_MUTECT2_REGULAR,
                                  STR_FILTERING_MUTECT2_LROM,
                                  STR_FILTERING_BCFTOOLS,
                                  STR_FILTERING_NONE]

STR_FILTERING_GATK = [STR_FILTERING_HC_REGULAR,
                                  STR_FILTERING_HC_CNN,
                                  STR_FILTERING_MUTECT2_REGULAR,
                                  STR_FILTERING_MUTECT2_LROM
                   ]

# File names required for filtering
C_STR_INIT_FILTER = "variants_initial_filtering.vcf"

# File name for cosmic filtering
C_STR_CANCER_ANNOTATED_VCF = "variants_annotated.vcf.gz"

# File name for CRAVAT filtering
C_STR_CANCER_VCF = "cancer.vcf"
C_STR_CANCER_TAB = "cancer.tab"

# Files for CRAVAT
STR_CRAVAT_CLASSIFIER_DEFAULT = "Other"
I_CRAVAT_ATTEMPTS = 180
I_CRAVAT_WAIT = 60
STR_FDR_CUTTOFF = "0.3"

BASEDIR = os.path.dirname(os.path.realpath(__file__))
STR_CRAVAT_HEADER_INFO = os.path.join(BASEDIR, "meta/cravat_annotation.txt")

# Mutation Inspector file
C_STR_MUTATION_INSPECTOR = "mutation_inspector.json"

## PLUGINS for SNPeff

PLUGINS_DIR = "plugins"
PLUGINS = os.path.join(BASEDIR,PLUGINS_DIR)

class RnaseqSnp:

    def RNA_star_alignment(self,
                           args_call,
                           index_dir,
                           genome_fa,
                           str_misc_dir):
            '''
            Input files : fastq, fastq.gz, input.bam
            Output : Aligned.sortedByCoord.out.bam.bai or input.bam.bai  (index file of alignment)
            ''' 

            
            str_star_sorted_bam = os.path.join(str_misc_dir, STR_STAR_OUTPUT_BAM)

            # Pipeline variables
            str_num_threads = str(args_call.i_number_threads)
            str_left = args_call.str_sample_file_left_fq
            str_right = args_call.str_sample_file_right_fq

            # Commands to build and return are stored in this list
            lcmd_commands = []

            
            ########################################
            ##### STAR in limited memory mode ######
            ########################################
            # Update the limitGenomeGenerateRAM if more memory is requested
            lstr_index_memory_size = []
            if hasattr(args_call, "str_star_memory_limit"):
                if((args_call.str_star_memory_limit) and
                   (args_call.str_alignment_mode == "STAR")):
                    lstr_index_memory_size.extend(["--limitGenomeGenerateRAM",
                                                   args_call.str_star_memory_limit])

            lstr_limited_index_mode = []
            if args_call.str_alignment_mode == "LIMITED":
                 lstr_limited_index_mode.append(" ".join(["--limitGenomeGenerateRAM",
                                                          "15000000000",
                                                          "--genomeSAsparseD 2",
                                                          "--outSAMmapqUnique 60",
                                                          "--limitIObufferSize",
                                                          "150000000"]))

            lstr_limited_alignment_mode = []
            if args_call.str_alignment_mode == "LIMITED":
                lstr_limited_alignment_mode.append("--genomeSAsparseD 2")

            
            if not args_call.str_bam_file:
                
                ###########################################
                #### Generate Index if not provided #######
                ###########################################
                # If the premade index is not given then generate
                if not index_dir:
                    index_dir = genome_fa + ".star.idx"
                    str_index = " ".join(["STAR", "--runMode", "genomeGenerate"] +
                                                lstr_limited_index_mode + lstr_index_memory_size +
                                                ["--genomeDir", index_dir,
                                                  "--outSAMmapqUnique", "60",
                                                 "--genomeFastaFiles", genome_fa,
                                                 "--runThreadN", str_num_threads])
                    lcmd_commands.append(Command(str_index, "star_index.ok"))
                
                ##########################################
                ###### Perform two-pass alignment ########
                ##########################################
                # Star Aligner
                lstr_gzip = []

                # Check if the files are gzipped or not
                str_ext_left = os.path.splitext(str_left)[1]
                str_ext_right = os.path.splitext(str_right)[1]
                if str_ext_left != str_ext_right:
                    str_error = " ".join(["Fastq files from a single sample should both",
                                          "either be gzipped (.gz) or not compressed."])
                    cur_pipeline.logr_logger.error(str_error)
                    exit(8)
                elif str_ext_left == ".gz":
                    lstr_gzip = ["--readFilesCommand", "\"gunzip -c\""]

                # Map files
                str_star_align = " ".join(["STAR",
                                           "--genomeDir", index_dir,
                                           "--runThreadN", str_num_threads,
                                           "--readFilesIn", str_left,
                                           str_right] + lstr_gzip + ["--outSAMtype",
                                                                     "BAM", "SortedByCoordinate",
                                                                     "--twopassMode", "Basic",
                                                                     "--limitBAMsortRAM", "30000000000",
                                                                     " --outSAMmapqUnique","60",
                                                                     "--outFileNamePrefix",
                                                                     str_misc_dir + os.sep])
                      
                lcmd_commands.append(Command(str_star_align, "star_alignment.ok"))


            # Create index of alignment bam and save ok file
            str_star_bai = " ".join(["samtools index", str_star_sorted_bam])
            lcmd_commands.append(Command(str_star_bai, "star_bai.ok"))
      
            return lcmd_commands, str_star_sorted_bam

    def RNA_refine_mapping(self, args_call, str_align_file, str_unique_id,
                            str_project_dir, str_tmp_dir,
                            genome_fa,vcf_file,
                            gatk_path,picard_path):
        """
        Manages the commands for the recalibration step in the GATK RNASEq mutation calling best practices.

        * args_call : Arguments for the pipeline
                    : Dict
        * str_align_file : The file from the alignment (sam or bam file). If sam file, will be changed to bam file
                         : File path
        * str_project_dir : Output directory
                          : String file path
        * str_tmp_dir : Directory used to put intermediary files (part of the pipeline organization
                      : String file path
        * lstr_dependencies : List of file paths of dependencies from any previously running commands.
                            : List of strings
        """
        # Check for the known vcf file
        # If it does not exist, warn that the associated steps will not be ran.
        if not vcf_file:
            warnings.warn("".join(["\n\n\nWARNING, WARNING, WARNING, WARNING.\n",
                          "GATK Recalibration: A vcf file with known variants was not provided for realignment and recalibration steps.\n",
                           "These steps may perform better if such a vcf file is provided.\n\n\n"]))

        # Files
        str_sorted_bam = os.path.join(str_tmp_dir, "sorted.bam") ## AddorReplaceDuplicates
        str_dedupped_bam = os.path.join(str_tmp_dir, "dedupped.bam") ## MarkDuplicates
        str_qc_metrics = os.path.join(str_tmp_dir, "mark_duplicates_qc_metrics.txt") ## MarkDuplicates
        str_split_bam = os.path.join(str_tmp_dir, "split.bam") ## SplitNCigars
        str_split_bai = os.path.join(str_tmp_dir, "split.bai") ## SplitNCigars
        str_recalibrated_alignment_file = os.path.join(str_tmp_dir, "recal_table.table") ## if vcf_file
        str_recalibrated_bam_2 = os.path.join(str_tmp_dir, "recalibrated_tmp.bam") ## if vcf_file
        str_recalibrated_bam = os.path.join(str_tmp_dir, "recalibrated.bam") ## if vcf_file
        str_recalibrated_bai = os.path.join(str_tmp_dir, "recalibrated.bai") ## if vcf_file
        str_recalibration_plots_pdf = os.path.join(str_tmp_dir, "recalibration.pdf") ## plot = True

        #str_return_bam = ""
        # Allows the known variants vcf file to be available or not.
        lcmd_gatk_recalibration_commands = []

        #############################################
        ############# RUN PICARD ####################
        #############################################

        ## AddOrReplaceReadGroups
        str_cur_command = "".join(["java -jar ", 
                         os.path.join(picard_path,"picard.jar"), 
                         " AddOrReplaceReadGroups", " I=", str_align_file,
                         " O=", str_sorted_bam, " SO=coordinate RGID=id RGLB=library RGPL=",
                          args_call.str_sequencing_platform, " RGPU=machine RGSM=", str_unique_id])

        lcmd_gatk_recalibration_commands.extend([Command(str_cur_command,'add_or_replace_read_groups.ok')])
        
        ## MarkDuplicates
        str_cur_command = "".join(["java -jar ", os.path.join(picard_path,"picard.jar"), " MarkDuplicates"," I=", str_sorted_bam, " O=", str_dedupped_bam,
                                                                           " CREATE_INDEX=true M=", str_qc_metrics])
        lcmd_gatk_recalibration_commands.extend([Command(str_cur_command,'mark_duplicates.ok')])

        
        ## SplitNCigarReads        
        str_cur_command = " ".join(["java -jar "+ gatk_path +" SplitNCigarReads -R", genome_fa,
                                                                                  "-I", str_dedupped_bam, "-O", str_split_bam,
                                                                                  "--read-validation-stringency LENIENT"])
        lcmd_gatk_recalibration_commands.extend([Command(str_cur_command,'split_cigar_reads.ok')])
        str_return_bam = str_split_bam
        str_return_bai = str_split_bai
        
        if vcf_file:
            ## BaseRecalibrator
            str_cur_command = " ".join(["java -Xmx4g -jar "+ gatk_path +" BaseRecalibrator -I",
                                                                          str_split_bam,
                                                                          "-R", genome_fa, "-O", str_recalibrated_alignment_file, "--known-sites", vcf_file])
            
            lcmd_gatk_recalibration_commands.extend([Command(str_cur_command,'base_recal.ok')])    

            ## PrintReads  
            str_cur_command = " ".join(["java -Xmx2g -jar ", gatk_path,
                                        " PrintReads", "-O", str_recalibrated_bam_2, "-I",
                                        str_split_bam])
            lcmd_gatk_recalibration_commands.extend([Command(str_cur_command,'printreads.ok')]) 

            ## ApplyBQSR
            str_cur_command = " ".join(["java -jar "+ gatk_path+" ApplyBQSR",
                                                    "-I", str_recalibrated_bam_2, "-O", str_recalibrated_bam,
                                                    "-bqsr", str_recalibrated_alignment_file])
            lcmd_gatk_recalibration_commands.extend([Command(str_cur_command,'apply_bqsr.ok')])             
            str_return_bam = str_recalibrated_bam
            str_return_bai = str_recalibrated_bai

            # AnalyzeCovariates
            if args_call.f_optional_recalibration_plot:                
                str_cur_command = " ".join(["java -Xmx4g -jar "+ gatk_path+" AnalyzeCovariates",
                                            "-bqsr", str_recalibrated_alignment_file,
                                            "-plots", str_recalibration_plots_pdf])
                lcmd_gatk_recalibration_commands.append(Command(str_cur_command,'analyze_covariate.ok'))
        
        return lcmd_gatk_recalibration_commands, str_return_bam, str_return_bai
    

    def Variant_Calling_GATK(self, args_call,
                             str_align_file,
                             str_unique_id,
                             str_project_dir,
                             str_tmp_dir,
                             genome_fa,
                             vcf_file,
                             gatk_path,
                             picard_path):


         # Commands which will be returned
        lcmd_gatk_variants_commands = []

        # Perform recalibration
        align_refine_cmd, str_return_bam, str_return_bai = self.RNA_refine_mapping(args_call,
                                                                                   str_align_file,
                                                                                   str_unique_id, str_project_dir,
                                                                                   str_tmp_dir,
                                                                                   genome_fa,vcf_file,
                                                                                   gatk_path,picard_path)
        lcmd_gatk_variants_commands.extend(align_refine_cmd)
   
        # Files
        str_variants_file = os.path.join(str_project_dir, "variants.vcf")

        # Create depth file
        if args_call.f_calculate_base_coverage:
            str_depth_compressed_file = os.path.basename(args_call.str_out_dir) + ".depth"
            str_depth_compressed_file = os.path.join(args_call.str_out_dir,
                                                     str_depth_compressed_file)
            str_depth = " ".join(["samtools", "depth", str_return_bam, ">", str_depth_compressed_file])
            lcmd_gatk_variants_commands.append(Command(str_depth,'dep.ok'))
        
        # Variant calling
        if args_call.str_gatk_variant_call_method == STR_GATK_HC:
            str_hap_call = " ".join(["java", "-jar", gatk_path,
                                     "HaplotypeCaller", "-R",
                                     genome_fa, "-I", str_return_bam,
                                     "--recover-dangling-heads","true",
                                     "--dont-use-soft-clipped-bases","-stand-call-conf",
                                     "20.0",
                                     "-O", str_variants_file])
            lcmd_gatk_variants_commands.append(Command(str_hap_call,'hap_call.ok'))
          
        elif args_call.str_gatk_variant_call_method == STR_GATK_MUTECT2 and args_call.str_germline_resource:
            # if germline_resource is provided
            f1r2_output = os.path.join(args_call.str_out_dir,"f1r2.tar.gz")
            gnomad = args_call.str_germline_resource #os.path.join(ctat_genome_lib_path,"ctat_mutation_lib", "af-only-gnomad.raw.sites.b37.vcf.gz")

            str_m2_call = " ".join(["java", "-jar", gatk_path,
                                     "Mutect2",
                                     "-R", genome_fa,
                                     "-I", str_input_bam,
                                     "--germline-resource", gnomad,
                                     "--f1r2-tar-gz", f1r2_output,
                                     "-O", str_variants_file])
            lcmd_gatk_rna_calling.append(Command(str_m2_call,'Mutect2_call_gnomad.ok'))
            
        elif args_call.str_gatk_variant_call_method == STR_GATK_MUTECT2 and not args_call.str_germline_resource:
            str_m2_call = " ".join(["java", "-jar",
                                    gatk_path,
                                    "Mutect2", "-R",
                                    genome_fa,
                                    "-I", str_return_bam,
                                    "--dont-use-soft-clipped-bases",
                                    "-stand-call-conf","20.0",
                                    "-A", "ReferenceBases", "-A", "QualByDepth",
                                    "-A", "FisherStrand", "-A", "ChromosomeCounts",
                                    "-O", str_variants_file])
            lcmd_gatk_rna_calling.append(Command(str_m2_call,'Mutect2_call.ok'))
        
        return lcmd_gatk_variants_commands, str_variants_file
            
    def Variant_Calling_USE_VCF(self, args_call,
                                     str_align_file,
                                     str_unique_id,
                                     str_project_dir,
                                     str_tmp_dir,
                                     genome_fa,
                                     gatk_path,
                                     picard_path):
        
        """
        use a vcf provided as a script parameter.  For more rapid testing of downstream operations only...
        """

        lcmd_index = []

        # symlink the vcf to the proj dir
        target_vcf_file = os.path.sep.join([str_project_dir, "variants.vcf"])
        lcmd_index.append(Command("ln -s {} {}".format(args_call.use_vcf_file, target_vcf_file), "symlink_use_vcf.ok"))
        lcmd_index.append(Command("ln -s {} {}".format(args_call.use_vcf_file + ".idx", target_vcf_file + ".idx"), "symlink_use_vcf_idx.ok"))

        return lcmd_index, target_vcf_file
    
    def func_do_filtering_gatk(self, args_call, str_variants_file, str_input_bam, gatk_path, genome_fa):
        """
        Creates the commands for the gatk hard filtering.
        * args_call: Arguments for the pipeline
                   : Dict
        * str_variants_file: Path to file to be filtered
                           : String path
        * lstr_dependencies: List of file paths of dependencies from any
                             previously running commands.
                           : List of strings
        * logr_cur: Pipeline logger
                  : Logger
        """
        lcmd_filter = []
        # Filtered variants file
        str_filtered_variants_file = os.path.join(args_call.str_out_dir,
                                                  C_STR_INIT_FILTER)
        # Filter variants
        ##########################################################
        ####### 1. Haplotype caller - VariantFiltration ##########
        ##########################################################
        if args_call.str_gatk_variant_call_method == STR_GATK_HC and args_call.str_variant_filter_mode == STR_FILTERING_HC_REGULAR :
            mutFilter_output = os.path.join(args_call.str_out_dir,"preFilterHCCalls.vcf")
            str_filter_command = " ".join(["java -jar",gatk_path,
                                           "VariantFiltration -R",
                                           genome_fa, "-V",
                                           str_variants_file, "-window 35",
                                           "-cluster 3 --filter-name FS",
                                           "-filter \"FS > 30.0\"",
                                           "--filter-name QD","-filter \"QD < 2.0\"",
                                           "-O", str_hc_filter_output])
            
            cmd_variant_filtration = Command(str_filter_command,'variant_filter.ok')
            lcmd_filter.append(cmd_variant_filtration)


            str_filter_command = " ".join(["java -jar",gatk_path,
                                            "SelectVariants",
                                            "-R", genome_fa,
                                            "-V", str_hc_filter_output,
                                            "-select-type SNP",
                                            "--exclude-filtered",
                                            "-O", str_filtered_variants_file])
            cmd_variant_filtration = Command(str_filter_command,'variant_select.ok')
            lcmd_filter.append(cmd_variant_filtration)
        
        ####################################################################################
        ### 2. Haplotype caller - CNNScoreVariants, FilterVariantTranches, SelectVariants ##
        ####################################################################################
        elif args_call.str_gatk_variant_call_method == STR_GATK_HC and args_call.str_variant_filter_mode == STR_FILTERING_HC_CNN:

            ## Resource files
            test_lib = os.path.join(args_call.genome_lib_dir,"ctat_mutation_lib")
            dbsnp = os.path.join(test_lib, "dbsnp_138.b37.vcf.gz")
            omni = os.path.join(test_lib, "1000G_omni2.5.b37.vcf.gz")
            hapmap = os.path.join(test_lib, "hapmap_3.3.b37.vcf.gz")
            high_conf = os.path.join(test_lib, "1000G_phase1.snps.high_confidence.b37.vcf.gz")
            
            str_score_file = os.path.join(args_call.str_out_dir, "scored.vcf")
            str_CNNScoreVariants_call = " ".join(["java", "-jar", gatk_path,
                                     "CNNScoreVariants",
                                     "-R", genome_fa,
                                     "-I", str_input_bam,
                                     "-V", str_variants_file,
                                     "--tensor-type read_tensor",
                                     "--transfer-batch-size 8",
                                     "--inference-batch-size 8",
                                     "-O", str_score_file])
            cmd_variant_filtration = Command(str_CNNScoreVariants_call,'CNNScoreVariants.ok')
            lcmd_filter.append(cmd_variant_filtration)
            

            str_trenche_file = os.path.join(args_call.str_out_dir, "trenche.vcf")
            str_tranche_command = " ".join(["java -jar",gatk_path,
                                           "FilterVariantTranches",
                                           "-R", genome_fa,
                                           "-V", str_score_file,
                                           "--resource", omni,
                                           "--resource", hapmap,
                                           "--info-key CNN_2D",
                                           "--snp-tranche 95.9",
                                           "--indel-tranche 95.0",
                                           "--invalidate-previous-filters",
                                           "-O", str_trenche_file])
            cmd_variant_filtration = Command(str_tranche_command,'tranche_filter.ok')
            lcmd_filter.append(cmd_variant_filtration)
            
            str_filter_command = " ".join(["java -jar",gatk_path,
                                            "SelectVariants",
                                            "-R", genome_fa,
                                            "-V", str_trenche_file,
                                            "-select-type SNP",
                                            "--exclude-filtered",
                                            "-O", str_filtered_variants_file])
            cmd_variant_filtration = Command(str_filter_command,'variant_cnn_filter.ok')
            lcmd_filter.append(cmd_variant_filtration)

        ## We will remove one of 3/4 depending on the benchmarking
        ##########################################################
        ###########  3. Mutect2 and FilterMutectCalls  ###########
        ##########################################################
        elif args_call.str_gatk_variant_call_method == STR_GATK_MUTECT2 and args_call.str_variant_filter_mode == STR_FILTERING_MUTECT2_REGULAR:
            mutFilter_output = os.path.join(args_call.str_out_dir,"preFilterMutectCalls.vcf")
            str_filter_command = " ".join(["java -jar",gatk_path,
                                           "FilterMutectCalls -R",
                                           genome_fa,
                                           "-V", str_variants_file,
                                           "-O", mutFilter_output])
            cmd_variant_filtration = Command(str_filter_command,'FilterMutectCalls.ok')

            str_filter_mut_command = " ".join(["java -jar",gatk_path,
                                            "SelectVariants",
                                            "-R", genome_fa,
                                            "-V", mutFilter_output,
                                            "-select-type SNP",
                                            "--exclude-filtered",
                                            "-O", str_filtered_variants_file]) 
            cmd_variant_filtration = Command(str_filter_mut_command,'variant_filter.ok')
            lcmd_filter.append(cmd_variant_filtration)
            
            lcmd_filter.append(cmd_variant_filtration)

        ##########################################################
        ################ 4. Mutect2 and LROM #####################
        ##########################################################
        elif args_call.str_gatk_variant_call_method == STR_GATK_MUTECT2 and args_call.str_variant_filter_mode == STR_FILTERING_MUTECT2_LROM:
            f1r2_output = os.path.join(args_call.str_out_dir,"f1r2.tar.gz")
            LROM_output = os.path.join(args_call.str_out_dir,"ob-priors.tar.gz")
            test_lib = os.path.join(ctat_genome_lib_path,"ctat_mutation_lib")
            common_exac = os.path.join(test_lib, "small_exac_common_3_b37.vcf.gz")
            pileups_output = os.path.join(args_call.str_out_dir,"tumor.pileups")
            contamination_output = os.path.join(args_call.str_out_dir,"contamination.table")
            segments_output = os.path.join(args_call.str_out_dir,"segments.table")
            mutFilter_output = os.path.join(args_call.str_out_dir,"preFilterMutectCalls.vcf")

            
            str_LROM_call = " ".join(["java", "-jar", gatk_path,
                                     "LearnReadOrientationModel",
                                     "-I", f1r2_output,
                                     "-O", LROM_output])
            cmd_variant_filtration = Command(str_LROM_call,'LearnReadOrientationModel.ok')
            lcmd_filter.append(cmd_variant_filtration)

            str_pileup_call = " ".join(["java", "-jar", gatk_path,
                                     "GetPileupSummaries",
                                     "-I ", str_input_bam,
                                     "-V", common_exac,
                                     "-L", common_exac,
                                     "-O ", pileups_output])
            cmd_variant_filtration = Command(str_pileup_call,'PileupSummaries.ok')
            lcmd_filter.append(cmd_variant_filtration)

            str_CalculateContamination_call = " ".join(["java", "-jar", gatk_path,
                                     "CalculateContamination",
                                     "-I ", pileups_output,
                                     "-O", contamination_output,
                                     "--tumor-segmentation", segments_output])
            cmd_variant_filtration = Command(str_CalculateContamination_call,'CalculateContamination.ok')
            lcmd_filter.append(cmd_variant_filtration)

            str_mutFilter_command = " ".join(["java -jar",gatk_path,
                                           "FilterMutectCalls",
                                           "-R", genome_fa,
                                           "-V", str_variants_file,
                                           "--tumor-segmentation", segments_output,
                                           "--contamination-table", contamination_output,
                                           "--ob-priors", LROM_output,
                                           "-O",mutFilter_output])
            cmd_variant_filtration = Command(str_mutFilter_command,'FilterMutectCalls.ok')
            lcmd_filter.append(cmd_variant_filtration)
            
            str_filter_mut_command = " ".join(["java -jar",gatk_path,
                                            "SelectVariants",
                                            "-R", genome_fa,
                                            "-V", mutFilter_output,
                                            "-select-type SNP",
                                            "--exclude-filtered",
                                            "-O", str_filtered_variants_file]) 
            cmd_variant_filtration = Command(str_filter_mut_command,'variant_filter.ok')
            lcmd_filter.append(cmd_variant_filtration)
            
        
        return lcmd_filter, str_filtered_variants_file

    def func_do_variant_filtering_cancer(self,
                                         args_call,
                                         cosmic_vcf,
                                         str_variants_file,
                                         str_project_dir,
                                         f_is_hg_38,
                                         gatk_path,
                                         genome_fa,
                                         cravat_header):
        """
        * args_call: Arguments for the pipeline
                   : Dict
        * str_variants_file: Path to file to be annotated and filtered
                           : String path
        * f_is_hg_38: Indicates if the reference is Hg38, Hg19, or something else (in which CRAVAT will not run)
                    : True (HG38), False (HG19), None (CRAVAT will not run)
        * return: List of commands
        """

        # TODO
        # ClinVAR, CADD for annotation?
        # TODO, Do all COMIC IDs represent pathogenic mutations, if not remove non-pathogenic variants with COSMIC IDS

        # Commands for cancer filtering
        lcmd_cancer_filter = []

        # Pull out and annotate Coding Cancer Mutations
        # Adding the following annotations from COSMIC
        # If the VCF does not have an annotation in COSMIC then it is dropped
        # GENE, COSMIC_ID, TISSUE, TUMOR, FATHMM, SOMATIC
        str_cancer_mutations_unfiltered = os.path.join(str_project_dir, STR_MISC_DIR, C_STR_CANCER_ANNOTATED_VCF)
        str_vcf_base = os.path.join(str_project_dir, STR_MISC_DIR, os.path.basename(os.path.splitext(str_variants_file)[0]))
        str_cancer_mutations_filtered = self.func_switch_ext(str_vcf_base, "_cosmic_filtered.vcf")
        str_cravat_filtered_groom_vcf = str_project_dir + os.path.sep + C_STR_CANCER_VCF # CRAVAT
        str_cravat_result_dir = self.func_switch_ext(str_vcf_base, "_cosmic_filtered_cravat_annotations.gz")
        str_extracted_cravat_dir = str_vcf_base + "_cosmic_filtered_cravat_annotations" # CRAVAT
        str_cravat_detail_coding = os.path.join(str_extracted_cravat_dir, "Variant.Result.tsv") #CRAVAT
        str_cravat_detail_noncoding = os.path.join(str_extracted_cravat_dir, "Variant_Non-coding.Result.tsv") #CRAVAT
        str_cravat_detail_coding_updated = os.path.join(str_project_dir, STR_MISC_DIR, "Variant_result_updated.tsv") #CRAVAT
        str_cravat_detail_noncoding_updated = os.path.join(str_project_dir, STR_MISC_DIR, "Variant_non_coding_result_updated.tsv") #CRAVAT
        str_cravat_annotated_coding_vcf = self.func_switch_ext(str_vcf_base, "_cosmic_filtered_cravat_annotated_coding.vcf.gz") #CRAVAT
        str_cravat_annotated_all_vcf = str_project_dir + os.path.sep + "annotated_min_filtered.vcf.gz" #CRAVAT
        str_cancer_tab = str_project_dir + os.path.sep + C_STR_CANCER_TAB
        
        if cosmic_vcf:
            # Annotate cancer variants with COSMIC
            str_cancer_annotation_command = " ".join(["bcftools", "annotate", "--output-type", "z",
                                                      "--annotations",cosmic_vcf,
                                                      "--columns", "INFO/COSMIC_ID,INFO/TISSUE,INFO/TUMOR,INFO/FATHMM,INFO/SOMATIC",
                                                      "--output", str_cancer_mutations_unfiltered, str_variants_file])
            lcmd_cancer_filter.append(Command(str_cancer_annotation_command,'cosmic.ok'))
            str_vcf_to_filter = str_cancer_mutations_unfiltered

        

        # Filter variant before CRAVAT
        str_cancer_filter_command = " ".join([os.path.sep.join([SCRIPTDIR, "filter_vcf_for_cancer.py"]),
                                              str_vcf_to_filter,
                                              str_cancer_mutations_filtered])
        lcmd_cancer_filter.append(Command(str_cancer_filter_command,'variant_before_cravat.ok'))


        
        # Annotate non-common with CRAVAT
        str_cmd_make_cravat_tab = " ".join(["java -jar",gatk_path, "VariantsToTable", "-R", genome_fa,"-V", str_cravat_filtered_groom_vcf,
                                           "-F", "CHROM", "-F", "POS", "-F", "REF", "-F", "ALT", "-F", "GENE",
                                           "-F", "DP", "-F", "QUAL", "-F", "MQ",
                                           "-F", "SAO", "-F", "NSF", "-F", "NSM", "-F", "NSN", "-F", "TUMOR", "-F", "TISSUE",
                                           "-F", "COSMIC_ID", "-F", "KGPROD", "-F", "RS", "-F", "PMC"])

        
       
        if (not args_call.f_skip_cravat):
            # Update the output target vcf file given these steps are ran.
            str_return_vcf = str_cravat_filtered_groom_vcf
            str_pred_filtered_vcf=self.func_switch_ext(str_vcf_base, "_cosmic_filtered_cravat_annotated_filtered.vcf")
            str_cmd_make_cravat_tab = " ".join([str_cmd_make_cravat_tab,
                                                "-F", "CHASM_PVALUE",
                                                "-F", "CHASM_FDR",
                                                "-F", "VEST_PVALUE",
                                                "-F", "VEST_FDR"])

            str_cravat_result_dir_zip = str_cravat_result_dir + ".zip"
            lstr_hg_38 = ["--is_hg19"] if not f_is_hg_38 else []
            str_cravat_cmd = " ".join([os.path.sep.join([SCRIPTDIR, "annotate_with_cravat.py"]),
                                       "--classifier", args_call.str_cravat_classifier] + lstr_hg_38 +
                                      ["--email", args_call.str_email_contact, "--max_attempts", str(I_CRAVAT_ATTEMPTS),
                                       "--wait", str(I_CRAVAT_WAIT), str_cancer_mutations_filtered, str_cravat_result_dir])
            lcmd_cancer_filter.append(Command(str_cravat_cmd,'annotate_cravat.ok'))

            
            ## Unzip
            str_unzip_cravat_cmd = " ".join(["unzip", "-d", str_extracted_cravat_dir, str_cravat_result_dir_zip])
            lcmd_cancer_filter.append(Command(str_unzip_cravat_cmd,'unzip.ok')) 

            # MV files needed from the CRAVAT dir to the current working dir.
            str_coding_variant_result = str_extracted_cravat_dir+os.path.sep+"*"+os.path.sep+"Variant.Result.tsv"
            str_non_coding_variant_result = str_extracted_cravat_dir+os.path.sep+"*"+os.path.sep+"Variant_Non-coding.Result.tsv"
            str_move_cravat_files = " ".join(["bash -c \"cp", "{"+str_coding_variant_result+","+str_non_coding_variant_result+"}", str_extracted_cravat_dir+"\""])
            lcmd_cancer_filter.append(Command(str_move_cravat_files,'mv_cravat.ok'))

            # Groom CRAVAT output tab for it does not upset BCFtools.
            str_groom_cravat_tab_coding = " ".join([os.path.sep.join([SCRIPTDIR, "groom_cravat_annotation.py"]),
                                                    str_cravat_detail_coding, str_cravat_detail_coding_updated])

            str_groom_cravat_tab_non_coding = " ".join([os.path.sep.join([SCRIPTDIR, "groom_cravat_annotation.py"]),
                                                        str_cravat_detail_noncoding, str_cravat_detail_noncoding_updated])
            cmd_groom_cravat_tab_coding = Command(str_groom_cravat_tab_coding,'cravat_coding.ok')
            cmd_groom_cravat_tab_noncoding = Command(str_groom_cravat_tab_non_coding,'cravat_non_coding.ok')
            lcmd_cancer_filter.extend([cmd_groom_cravat_tab_coding, cmd_groom_cravat_tab_noncoding])

            # Tabix index the CRAVAT tsv files
            tabix_cmd = self.func_tabix(str_cravat_detail_coding_updated, str_output_dir = os.path.join(str_project_dir, STR_MISC_DIR))
            lcmd_cancer_filter.extend(tabix_cmd)
            str_cravat_detail_coding_updated = str_cravat_detail_coding_updated +".gz"
            tabix_cmd = self.func_tabix(str_cravat_detail_noncoding_updated, str_output_dir = os.path.join(str_project_dir, STR_MISC_DIR))
            lcmd_cancer_filter.extend(tabix_cmd)
            str_cravat_detail_noncoding_updated = str_cravat_detail_noncoding_updated +".gz"

            ## Annotate and VCF file with TAB data.
            ## CRAVAT gives both Coding and none coding Variants results.
            ## For now, including both and not excluding noncoding.
            str_annotate_coding = " ".join(["bcftools",
                                            "annotate",
                                            "--annotations",
                                            str_cravat_detail_coding_updated,
                                            "-h", cravat_header,
                                            "--columns",
                                            "\"CHROM,POS,CHASM_PVALUE,CHASM_FDR,VEST_PVALUE,VEST_FDR,MuPIT\"",
                                            "--output-type",
                                            "z",
                                            "--output",
                                            str_cravat_annotated_coding_vcf,
                                            str_cancer_mutations_filtered])
            lcmd_cancer_filter.append(Command(str_annotate_coding,'annotate_coding.ok'))
            str_annotate_noncoding = " ".join(["bcftools",
                                               "annotate",
                                               "--annotations",
                                               str_cravat_detail_noncoding_updated,
                                               "-h",
                                               cravat_header,
                                               "--columns",
                                               "\"CHROM,POS,CHASM_PVALUE,CHASM_FDR,VEST_PVALUE,VEST_FDR\"",
                                               "--output-type",
                                               "z",
                                               "--output",
                                               str_cravat_annotated_all_vcf,
                                               str_cravat_annotated_coding_vcf])
            lcmd_cancer_filter.append(Command(str_annotate_noncoding,'annotate_noncoding.ok'))
            # Filter based on Predictions
            str_cmd_filter_predictions = " ".join([os.path.sep.join([SCRIPTDIR, "filter_vcf_for_predictions.py"]),
                                                   str_cravat_annotated_all_vcf,
                                                   str_pred_filtered_vcf])
            lcmd_cancer_filter.append(Command(str_cmd_filter_predictions,'filter_predictions.ok'))

        
        
        # Groom before filter
        str_cmd_groom_cancer_filtered = " ".join([os.path.sep.join([SCRIPTDIR, "groom_vcf.py"]),
                                                  str_pred_filtered_vcf,
                                                  str_cravat_filtered_groom_vcf])
        lcmd_cancer_filter.append(Command(str_cmd_groom_cancer_filtered,'groom_filter.ok'))

        # Convert filtered VCF file to tab file.
        str_cmd_make_cravat_tab = " ".join([str_cmd_make_cravat_tab,
                                            "--lenient",
                                            "-O", str_cancer_tab])
        lcmd_cancer_filter.append(Command(str_cmd_make_cravat_tab,'vcf_tab.ok'))


        return lcmd_cancer_filter, str_cancer_tab
        

    def func_switch_ext(self, str_file, str_ext):
            """
            Changes the extension of a file to another extension.
            Convenience function for pipeline building.
            * str_file : File path to modify.
                   : String
            * str_ext : Extension to use in place of the current extension.
                  : String
            * return : Updated path for the file using a new extension.
                 : String (file path)
            """
            if (not str_file) or (not str_ext):
                return str_file
            if not (str_ext[0] in ["_", "."]):
                str_ext = "." + str_ext
            return os.path.splitext(str_file)[0] + str_ext

    def build_pipeline_cmds(self, args_parsed):
           ###make_commands
            """
            Builds the pipeline. This is placed in a function so that multiple
            scripts with different arguments requirements can run it.
            For instance, one script managing the complete pipeline requiring
            many more arguments while having a simple script running only the
            first indexing step to make a global index useable in all subsequent
            runs associated with the reference genome generating the index.
            * args_parsed : Arguments
                        : Arguments used to run pipeline.

            """
            import warnings
            
            #Check if GATK_HOME is provided
            gatk_home=os.getenv("GATK_HOME")
            if not gatk_home:
                exit("Error, missing path to GATK in $GATK_HOME.")

            # identify gatk4_jar file
            gatk4_jar = glob.glob(os.path.join(gatk_home, "gatk-package-4.*-local.jar"))
            if len(gatk4_jar) != 1:
                raise RuntimeError("Error, cannot locate single gatk-package-4.*-local.jar in {}".format(gatk_home))
            gatk_path = os.path.abspath(gatk4_jar[0])
            
            #Check if PICARD_HOME is provided
            picard_path = os.getenv("PICARD_HOME")
            if not picard_path:
                exit("Error, missing path to PICARD in $PICARD_HOME.")

            # Check if CTAT_GENOME_LIB present
            ctat_genome_lib_path = args_parsed.genome_lib_dir
            if not ctat_genome_lib_path:
                exit("Error, missing path to CTAT_GENOME_LIB in $CTAT_GENOME_LIB.")


            #############################################################
            ####### CHECK IF FILES PRESENT IN THE CTAT_GENOME_LIB #######
            #############################################################

            # genome.fa
            genome_fa = os.path.join(ctat_genome_lib_path, "ref_genome.fa")            
            if args_parsed.str_genome_fa:
                genome_fa = args_parsed.str_genome_fa

            # star index
            index_dir = os.path.join(ctat_genome_lib_path,"ref_genome.fa.star.idx")
            if args_parsed.str_index_dir:
                index_dir = args_parsed.str_index_dir
            
            # dbsnp vcf
            dbsnp_vcf_file = os.path.join(ctat_genome_lib_path,"ctat_mutation_lib", "dbsnp_138.vcf.gz")
            if args_parsed.dbsnp_vcf_file:
                dbsnp_vcf_file=args_parsed.dbsnp_vcf_file

            # reference bed file for IGV mutation inspector
            ref_bed = os.path.join(ctat_genome_lib_path,"ctat_mutation_lib", "refGene.sort.bed")
            if args_parsed.str_ref_bed:
                ref_bed = args_parsed.str_ref_bed

            # cravat header
            # cravat header
            cravat_header = STR_CRAVAT_HEADER_INFO
            
            if args_parsed.str_cravat_headers is not None:
                cravat_header = args_parsed.str_cravat_headers

            # ctat_mutation_lib
            properties=os.path.join(ctat_genome_lib_path,"ctat_mutation_lib",
                                                     "properties.json")
            if not os.path.exists(properties):
                exit("Error, cannot find properties.json file in $CTAT_GENOME_LIB/ctat_mutation_lib")

            ###############################################
            #### check if cosmic.vcf is generated #########
            ###############################################

            cosmic_vcf=os.path.join(ctat_genome_lib_path,"ctat_mutation_lib", "cosmic.vcf.gz") 
            if args_parsed.str_cosmic_vcf is not None:
                cosmic_vcf=args_parsed.str_cosmic_vcf
            
            
            # Fastq files or bam files must be given or index only should be true
            if(not (args_parsed.str_sample_file_left_fq
                    and args_parsed.str_sample_file_right_fq)
               and not args_parsed.str_bam_file):
               str_error = "".join(["RNASEQ MUTATION PIPELINE, please make",
                                    "sure to inclue a bam file or paired",
                                    "fastq files unless running in index",
                                    "only mode (which does no mutation calling)."])
               warnings.warn(str_error)
               exit(7)


            # set full paths in case of relative path settings
            if args_parsed.str_bam_file:
                args_parsed.str_bam_file = os.path.abspath(args_parsed.str_bam_file)
            if args_parsed.use_vcf_file:
                args_parsed.use_vcf_file = os.path.abspath(args_parsed.use_vcf_file)
            
            # Constants
            # If not using a premade index, do not update the
            # name of the index dir with the sample name. Does not need to be
            # unique. Otherwise update the name of the index directory so it is
            # unique, in case the pipeline is ran for multiple samples at once.
            str_sample_postfix = os.path.splitext(
                os.path.basename(
                    args_parsed.str_sample_file_left_fq if args_parsed.str_sample_file_left_fq else args_parsed.str_bam_file
                    ))[0]
            
            str_sample_postfix = str_sample_postfix.replace(".","_")
            

            # If the output directory is not given, get the file base from a sample file
            if not args_parsed.str_out_dir:
                args_parsed.str_out_dir = str_sample_postfix

            # Make sure the output directory is absolute
            args_parsed.str_out_dir = os.path.abspath(args_parsed.str_out_dir)

            # Base outputs on the sample file unless an output directory is given directories
            str_misc_dir = os.path.join(args_parsed.str_out_dir, STR_MISC_DIR)

            # Start commands
            lcmd_commands = []
            dict_align_info = {}

            if not os.path.exists(str_misc_dir):
                os.mkdir(str_misc_dir)


            ## Run STAR alignment
            star_align_cmd, str_align_file = self.RNA_star_alignment(args_call=args_parsed,
                                                           index_dir=index_dir,
                                                           genome_fa=genome_fa,
                                                           str_misc_dir = str_misc_dir)
            lcmd_commands.extend(star_align_cmd)
            
            ## Refine mapping using PICARD
            
            refine_mapping_cmd, str_return_bam, str_return_bai = self.RNA_refine_mapping(args_call=args_parsed,
                                                str_align_file = str_align_file,
                                                str_unique_id=str_sample_postfix, 
                                                str_project_dir=args_parsed.str_out_dir,
                                                str_tmp_dir=str_misc_dir,
                                                genome_fa=genome_fa,
                                                vcf_file=dbsnp_vcf_file,
                                                gatk_path=gatk_path,
                                                picard_path=picard_path)

            lcmd_commands.extend(refine_mapping_cmd)
            
            ## Variant Calling
            '''
            if args_parsed.str_variant_call_mode == STR_VARIANT_SAMTOOLS:
                variant_calling_cmd, str_variant_file = self.Variant_Calling_SAMTOOLS(args_call = args_parsed,
                                                                             str_align_file = str_align_file,
                                                                             str_unique_id = str_sample_postfix,
                                                                             str_project_dir = args_parsed.str_out_dir,
                                                                             str_tmp_dir = str_misc_dir,
                                                                             genome_fa= genome_fa,
                                                                             vcf_file = dbsnp_vcf_file,
                                                                             gatk_path=gatk_path,
                                                                             picard_path=picard_path)

            '''
                
            if args_parsed.str_variant_call_mode == STR_VARIANT_GATK:
                variant_calling_cmd, str_variant_file = self.Variant_Calling_GATK(args_call = args_parsed,
                                                                             str_align_file = str_align_file,
                                                                             str_unique_id = str_sample_postfix,
                                                                             str_project_dir = args_parsed.str_out_dir,
                                                                             str_tmp_dir = str_misc_dir,
                                                                             genome_fa= genome_fa,
                                                                             vcf_file = dbsnp_vcf_file,
                                                                             gatk_path=gatk_path,
                                                                             picard_path=picard_path)

            elif args_parsed.str_variant_call_mode == STR_VARIANT_NONE:
                variant_calling_cmd, str_variant_file = self.Variant_Calling_USE_VCF(args_call = args_parsed,
                                                                             str_align_file = str_align_file,
                                                                             str_unique_id = str_sample_postfix,
                                                                             str_project_dir = args_parsed.str_out_dir,
                                                                             str_tmp_dir = str_misc_dir,
                                                                             genome_fa= genome_fa,
                                                                             gatk_path=gatk_path,
                                                                             picard_path=picard_path)
                
                
            lcmd_commands.extend(variant_calling_cmd)

            ## Variant Filtering - BCFTOOLS, HC, MUTECT2, NONE
            '''
            if args_parsed.str_variant_filter_mode == STR_FILTERING_BCFTOOLS:
                filter_cmd, str_filtered_variants_file = self.func_do_filtering_bcftools(args_call=args_parsed,
                                                             str_variants_file=str_variant_file)
            '''
            if args_parsed.str_variant_filter_mode in STR_FILTERING_GATK:
                filter_cmd, str_filtered_variants_file = self.func_do_filtering_gatk(args_call=args_parsed,
                                                                                     str_variants_file=str_variant_file,
                                                                                     str_input_bam = str_return_bam,
                                                                                     gatk_path=gatk_path,
                                                                                     genome_fa = genome_fa)
                
            elif args_parsed.str_variant_filter_mode == STR_FILTERING_NONE:
                filter_cmd = []
                str_filtered_variants_file = str_variant_file

            lcmd_commands.extend(filter_cmd)
            
            # Clean up VCF file after variant caller
            str_annotated_vcf_file = str_filtered_variants_file
            str_clean_vcf = os.path.join(str_misc_dir,
                                         self.func_switch_ext(os.path.basename(str_annotated_vcf_file),
                                         "_clean.vcf"))
            str_clean_vcf_cmd = " ".join([os.path.sep.join([SCRIPTDIR, "groom_vcf.py"]),
                                          str_annotated_vcf_file,
                                          str_clean_vcf])

            lcmd_commands.append(Command(str_clean_vcf_cmd,'vcf_clean.ok'))
            str_annotated_vcf_file = str_clean_vcf


            # Filter results to just SNPs
            str_snp_filtered_vcf = self.func_switch_ext(str_annotated_vcf_file, "_snp.vcf")
            str_cmd_filter_snps = " ".join([os.path.sep.join([SCRIPTDIR, "reduce_vcf_to_snps.py"]),
                                            str_annotated_vcf_file, str_snp_filtered_vcf])
            lcmd_commands.append(Command(str_cmd_filter_snps,'filter_only_snps.ok'))
            str_annotated_vcf_file = str_snp_filtered_vcf

            # Filter RNA Editing
            if not args_parsed.no_filter_rna_editing:
                
                # rediportal
                rediportal_bed = os.path.join(ctat_genome_lib_path,"ctat_mutation_lib", "rediportal.txt")

                # radar
                radar_bed = os.path.join(ctat_genome_lib_path,"ctat_mutation_lib", "radar.txt")
                
                str_rna_edit_filtered_vcf = self.func_switch_ext(str_annotated_vcf_file, "_RNAedit.vcf")

                lstr_cmd_rna_editing_filter = [os.path.sep.join([SCRIPTDIR, "filter_snps_rna_editing.py"])]

                lstr_cmd_rna_editing_filter.extend(["--radar", radar_bed])
                lstr_cmd_rna_editing_filter.extend(["--rediportal", rediportal_bed])
                
                lstr_cmd_rna_editing_filter.extend([str_annotated_vcf_file, str_rna_edit_filtered_vcf])
                str_cmd_rna_editing_filter = " ".join(lstr_cmd_rna_editing_filter)
                lcmd_commands.append(Command(str_cmd_rna_editing_filter,'rna_edit.ok')) 

                # Switch over the annotated VCF to this RNA-Edited annotated VCF
                str_annotated_vcf_file = str_rna_edit_filtered_vcf

            ## gip --> variants_initial_filtering_clean_snp_RNAedit.vcf
            lcmd_index, str_gz = self.func_gz(str_annotated_vcf_file,
                                       args_parsed.str_out_dir)

            lcmd_commands.extend(lcmd_index)

            ## csi index
            lcmd_index, str_csi = self.func_csi(str_gz,
                                                args_parsed.str_out_dir)

            lcmd_commands.extend(lcmd_index)


            # Tabix / gz DBSNP
            lcmd_index, str_dbsnp_gz = self.func_gz(dbsnp_vcf_file,
                                       args_parsed.str_out_dir)
            lcmd_commands.extend(lcmd_index)

            lcmd_index, str_dbsnp_csi = self.func_csi(str_dbsnp_gz,
                                                      args_parsed.str_out_dir)
            lcmd_commands.extend(lcmd_index)

            str_compressed_dbsnp = dbsnp_vcf_file
            str_csi_dbsnp = str_dbsnp_csi


            # DBSNP annotation
            # Annotate combined sample vcf files
            # bcftools annotate --annotations str_dbsnp_vcf -c
            # PM variant is clinicall precious (clinical and pubmed cited)
            # NSF, NSM, NSN, COMMON, SAO, KGPROD, KGVALIDATED, MUT, WTD, VLD, RS, PMC
            str_dbsnp_annotated_vcf = self.func_switch_ext(str_annotated_vcf_file, "_dbsnp.vcf.gz")
            str_annotate_command = "".join(["bcftools", " annotate",
                                             " --output-type", " z",
                                            " --annotations ",
                                             str_compressed_dbsnp,
                                             " --columns ",
                                             "INFO/COMMON,INFO/PM,INFO/NSF,",
                                             "INFO/NSM,INFO/NSN,INFO/SAO,",
                                             "INFO/KGPROD,INFO/KGValidated,",
                                             "INFO/MUT,INFO/WTD,INFO/VLD,",
                                             "INFO/RS,INFO/PMC", " --output ",
                                             str_dbsnp_annotated_vcf,
                                             " ", str_gz])
            lcmd_commands.append(Command(str_annotate_command,'dbsnp.ok'))


            ## SNPeff
            with open(properties,"r") as pr:
                property_dict=json.load(pr)
            gv=property_dict["Genome_version"]
            str_snp_eff_annotated = self.func_switch_ext(str_annotated_vcf_file, "_snpeff.vcf")
            str_snp_eff_cmd = " ".join(["bgzip -cd", str_gz,
                                        "|", "java -jar ", os.path.join(PLUGINS,"snpEff.jar "),"-nostats",
                                        "-noLof -no-downstream -no-upstream",
                                        gv, ">", str_snp_eff_annotated])
            lcmd_commands.append(Command(str_snp_eff_cmd,'snp_eff.ok'))
            str_annotated_vcf_file = str_snp_eff_annotated


            # Update the SNPeff style annotations to the simple info column feature style
            str_snp_eff_updated_file = self.func_switch_ext(str_annotated_vcf_file, "_updated.vcf")
            str_snp_eff_update_cmd = " ".join([os.path.sep.join([SCRIPTDIR,"update_snpeff_annotations.py"]),
                                               str_annotated_vcf_file, str_snp_eff_updated_file])
            lcmd_commands.append(Command(str_snp_eff_update_cmd,'snpeff_simple.ok'))
            str_annotated_vcf_file = str_snp_eff_updated_file


            # Perform cancer filtering
            if args_parsed.str_email_contact is None:
                warnings.warn("CRAVAT analysis will not be ran. Please specify an email address registered with CRAVAT service")
            if gv=="hg19":
                f_cravat_hg38=False
            else: 
                f_cravat_hg38=True

            # Index and bgzip vcf
            lcmd_index, str_annotated_vcf_gz = self.func_gz(str_annotated_vcf_file,
                                       args_parsed.str_out_dir)
            lcmd_commands.extend(lcmd_index)
            lcmd_index, str_annotated_vcf_csi = self.func_csi(str_annotated_vcf_gz,
                                                      args_parsed.str_out_dir)
            lcmd_commands.extend(lcmd_index)


            cmd_filter_cancer, str_cancer_tab = self.func_do_variant_filtering_cancer(args_call=args_parsed,
                                                                      cosmic_vcf = cosmic_vcf,
                                                                      str_variants_file=str_annotated_vcf_gz,
                                                                      str_project_dir = args_parsed.str_out_dir,
                                                                      f_is_hg_38 = f_cravat_hg38,
                                                                      gatk_path = gatk_path,
                                                                      genome_fa = genome_fa,
                                                                      cravat_header = cravat_header)
            
            
            lcmd_commands.extend(cmd_filter_cancer)


            # Make JSON file for the inspector
            str_json_inspector_file = args_parsed.str_out_dir + os.path.sep + C_STR_MUTATION_INSPECTOR
            if ref_bed:
                str_cmd_json_inspector = " ".join([ os.path.sep.join([SCRIPTDIR, "make_mutation_inspector_json.py"]),
                                            "--sample", args_parsed.str_out_dir,
                                            "--tab", str_cancer_tab,
                                            "--bam", str_return_bam, 
                                            "--bam_index", str_return_bai,
                                            "--bed", ref_bed,
                                            "--bed_index", ref_bed + ".idx",
                                            str_json_inspector_file])
                lcmd_commands.append(Command(str_cmd_json_inspector,'json_inspector.ok')) 

                # Copy bed to output to make it an output for Galaxy and allow it to be used in the inspector.
                str_copied_bed = os.path.join(args_parsed.str_out_dir, os.path.basename(ref_bed))
                str_cmd_copy_bed = " ".join(["cp", ref_bed, str_copied_bed])
                lcmd_commands.append(Command(str_cmd_copy_bed,'copy_bed.ok'))

                html_out=os.path.join(args_parsed.str_out_dir,"igvjs_viewer.html") 
                str_cmd_html = " ".join([ "report",
                                           os.path.join(args_parsed.str_out_dir,"cancer.vcf"),
                                           genome_fa,
					   "--flanking", "1000",
                                           "--info-columns","GENE TISSUE TUMOR COSMIC_ID GENE SOMATIC CHASM_PVALUE CHASM_FDR VEST_PVALUE VEST_FDR MuPIT",
                                           "--tracks", str_return_bam+" "+ref_bed+".gz",
					   "--output", html_out])
                lcmd_commands.append(Command(str_cmd_html, 'igv_html_viz.ok'))

            ## Run pipeline
            return lcmd_commands


    def func_gz(self, str_vcf, str_output_dir = ""):
          """
              Creates a bcftools index (vcf index) for the given vcf file.
              If it is not gzipped, the directory it is in is checked for a gz file.
              If the gz file does not exist the file is gzipped.
          """
          lcmd_index = []

          # Check extension
          if str_vcf.endswith(".gz"):
                  str_gz = str_vcf
          else:
                  # GZ files
                  str_gz = str_vcf + ".gz"
                  if str_output_dir:
                      str_gz = os.path.join(str_output_dir, os.path.basename(str_gz))
                  str_cmd_gz = " ".join(["bgzip -c ", str_vcf, ">", str_gz])
                  ok_file = ntpath.basename(str_vcf)+'.gz.ok'
                  lcmd_index.append(Command(str_cmd_gz,ok_file))
                  
          return lcmd_index,  str_gz


    def func_csi(self, str_gz, str_output_dir = ""):
              """
                  Creates a bcftools index (vcf index) for the given vcf file.
                  If it is not gzipped, the directory it is in is checked for a gz file.
                  If the gz file does not exist the file is gzipped.
                  A csi file is also made if it does not exist using the gz file.
              """
              lcmd_index = []
              str_index_file = str_gz + ".csi"

              str_cmd_index_vcf = " ".join(["bcftools index -f", str_gz,">",str_index_file])

              ok_file = ntpath.basename(str_gz)+'.vcf_csi.ok'
              lcmd_index.append(Command(str_cmd_index_vcf, ok_file))

              return lcmd_index, str_index_file

    def func_tabix(self, str_vcf, str_output_dir = ""):
          """
              Creates a tbi (vcf index) for the given vcf file.
              If it is not gzipped, the directroy is checked for the gz file.
              If the gz file does not exist, the file is gzipped.
              The tbi file is then made from the gz file.
          """

          # Gzip
          lcmd_tabix, str_gz = self.func_gz(str_vcf, str_output_dir)
          str_tabix = "-s 1 -b 2 -e 2 -S 12"

          if not str_vcf.endswith(".tbi"):
              # Create index for the VCF file
              str_tbi = str_gz + ".tbi"
              if str_output_dir:
                  str_tbi = os.path.join(str_output_dir, os.path.basename(str_tbi))
              str_cmd_tabix_vcf = " ".join(["tabix -f", str_tabix, str_gz])
              
              ok_file = ntpath.basename(str_gz) + '.vcf_tabix.ok'
              lcmd_tabix.append(Command(str_cmd_tabix_vcf,ok_file))
              
          return lcmd_tabix


def make_menu():

    ## Input Arguments
    args_parser = argparse.ArgumentParser(
        description = "Performs mutation detection in RNA-Seq"
        )
    

    ## Required arguments
    
    required = args_parser.add_argument_group('required arguments')
    
    required.add_argument( "--left", metavar = "Left_sample_file", dest = "str_sample_file_left_fq",
                           required = False, help = "Path to one of the two paired RNAseq samples (left)")
    
    required.add_argument( "--right", metavar = "Right_sample_file", dest = "str_sample_file_right_fq",
                           required = False, help = "Path to one of the two paired RNAseq samples (right)")
    
    required.add_argument("--out_dir", dest="str_out_dir", required=True, help="output directory")

    ## Optional arguments
    
    optional = args_parser.add_argument_group('optional arguments')

    optional.add_argument("--threads", metavar = "Process_threads", dest = "i_number_threads",
                          type = int, default = 1, help = "The number of threads to use for multi-threaded steps.")
    optional.add_argument("--debug", action="store_true", help="sets debug mode for logger")


    # STAR alignment
    optional.add_argument("--alignment_mode", metavar = "Alignment_mode", dest = "str_alignment_mode",
                          default = STR_ALIGN_STAR, 
                          help = "Specifies the alignment and indexing algorithm to use.")

    optional.add_argument("--star_memory", metavar = "Star_memory", dest = "str_star_memory_limit",
                          default = None,
                          help = "Memory limit for star index. This should be used to increase memory if needed. Reducing memory consumption should be performed with the STAR Limited mod.")

    
    # Resources
    optional.add_argument("--genome_lib_dir",dest="genome_lib_dir", type=str,
                          default=os.environ.get('CTAT_GENOME_LIB'),
                          help="genome lib directory - see http://FusionFilter.github.io for details.  Uses env var CTAT_GENOME_LIB as default")
    optional.add_argument( "--reference", metavar = "Reference_genome", dest = "str_genome_fa",
                           required = False, default=None,
                           help = "Path to the reference genome to use in the analysis pipeline.")

    optional.add_argument("--index", metavar = "Use_premade_index", dest = "str_index_dir",
                          required = False, default = None,
                          help = "The initial index is made only from the reference genome and can be shared. If premade, supply a path here to the index directory so that it is not rebuilt for every alignment. Please provide the full path.")

    optional.add_argument( "--dbsnp_vcf", metavar = "Variant_calling_file_for_the_reference_genome",
                        dest = "dbsnp_vcf_file", default = None,
                           help = "dbsnp vcf file for the reference genome.")

    optional.add_argument("--ref_bed", metavar = "Reference BED file", dest = "str_ref_bed", default=None,
                          help = "Bed file for reference genome, required only if making the mutation inspector json. If given the json file will be made. Please make sure the bed file is indexed and that bed.idx file is in the same folder with the same file basename as the related bed file.")

    optional.add_argument("--cravat_annotation_header", metavar = "cravat_headers",
                          dest = "str_cravat_headers", required=False, default = None,
                          help = "Headers for each CRAVAT feature annotated to the VCF file (used in BCFtools).")

    optional.add_argument("--cosmic_vcf_gz", metavar="cosmic_reference_vcf", dest="str_cosmic_vcf",
                          default=None,
                          help="Coding Cosmic Mutation VCF annotated with Phenotype Information and zipped using bgzip.")

    optional.add_argument("--bam", metavar = "bam_file", dest = "str_bam_file", default = None,
                          help = "Sample file in the form of a bam, if this is given NO alignment will be performed; the alignment mode command line will be ignored; let and right sample files will be ignored. Normal pipeline processing will pick up directly after alignment in the pipeline with the supplied bam.")

    ### GATK arguments:
    optional.add_argument("--variant_call_mode", metavar = "call_mode", dest = "str_variant_call_mode",
                          default = STR_VARIANT_GATK, choices = LSTR_VARIANT_CALLING_CHOICES,
                          help = "Specifies the variant calling method to use.")

    gatk_args_group = args_parser.add_argument_group('GATK associated optional args')
    
    gatk_args_group.add_argument( "--no_recalibrate_bam", dest = "f_no_recalibrate_bam", default = False,
                                action="store_true", help = "If used, turns off gatk recalibration of bam files before samtools variant calling.")


    gatk_args_group.add_argument("--gatk_variant_call_method", metavar = "GATK Variant Call Method", dest = "str_gatk_variant_call_method",
                                 default = STR_GATK_HC, choices = LSTR_VARIANT_METHOD_CHOICES,
                                 help = "Specifies the GATK variant calling method.")
    
    picard_args_group = args_parser.add_argument_group('GATK associated optional args')

    picard_args_group.add_argument("--sequencing_platform", metavar = "Sequencing Platform",
                                 dest = "str_sequencing_platform", default = "ILLUMINA", choices = LSTR_SEQ_CHOICES,
                                 help = "The sequencing platform used to generate the samples choices include " + " ".join(LSTR_SEQ_CHOICES) + ".")

    optional.add_argument("--plot", dest = "f_optional_recalibration_plot", default = False, help = "Turns off plotting recalibration of alignments.")

    ## Samtools Variant Calling
    optional.add_argument("--base_depth", dest = "f_calculate_base_coverage", default = False, help = "Calculates the base coverage per base.")

    ## Use vcf instead of variant calling 
    args_parser.add_argument('--use_vcf', dest="use_vcf_file", type=str, default=None,  help=argparse.SUPPRESS)
    
    ## Variant Filtering modes
    optional.add_argument("--variant_filtering_mode", metavar = "Filter_mode", dest = "str_variant_filter_mode",
                        default = STR_FILTERING_HC_REGULAR, choices = LSTR_VARIANT_FILTERING_CHOICES,
                          help = "Specifies the variant filtering method.")

    optional.add_argument("--germline_resource", metavar = "germline_resource", dest = "str_germline_resource",
                        default = None, help = "Germline resource file for Mutect2")


    ## RNA Editing
    optional.add_argument("--no_filter_rna_editing", action="store_true",
                          help="if enabled, turns off filtering based on known rna-editing sites from radar and rediportal")

    ## Email for CRAVAT
    optional.add_argument("--email", metavar = "email_contact", dest = "str_email_contact",
                          default = "noreply@domain.com", help = "Email used to notify of errors associated with cravat.")

    optional.add_argument("--skip_cravat", dest = "f_skip_cravat", action="store_true", default = False,
                          help = "Skips CRAVAT services.")
    optional.add_argument("--tissue_type", metavar = "cravat_tissue", dest = "str_cravat_classifier",
                          default = STR_CRAVAT_CLASSIFIER_DEFAULT,
                          help = "Tissue type (used in CRAVAT variant prioritation). Supported classifiers can be found at http://www.cravat.us/help.jsp)")
    

    return args_parser
    


if __name__ == "__main__":
    
    args_parser = make_menu()
    
    args_parsed = args_parser.parse_args()

    if args_parsed.debug:
        logger.setLevel(logging.DEBUG)
    
    ## Make Checkpoints directory
    checkpoints_dir = os.path.join(args_parsed.str_out_dir,"chckpts_dir")
    checkpoints_dir = os.path.abspath(checkpoints_dir)
    if not os.path.exists(checkpoints_dir):
        os.makedirs(checkpoints_dir)

    str_misc_dir = os.path.join(args_parsed.str_out_dir, STR_MISC_DIR)
    if not os.path.exists(str_misc_dir):
        os.mkdir(str_misc_dir)
    
    ## Construct pipeline
    pipeliner = Pipeliner(checkpoints_dir)

    # Need to rn, call the script
    lcmd_cmds = RnaseqSnp().build_pipeline_cmds(args_parsed)

    for cmd in lcmd_cmds:
        pipeliner.add_commands([cmd])
    pipeliner.run()

    sys.exit(0)
